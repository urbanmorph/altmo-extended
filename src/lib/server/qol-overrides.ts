/**
 * Shared QoL overrides builder — SINGLE SOURCE OF TRUTH for all live data overrides.
 *
 * Fetches live data from all automated sources and assembles a QoLOverrides object
 * for use in computeCityQoL(). Every page that displays QoL scores calls this function.
 *
 * IMPORTANT: When adding a new live data source, wire it HERE so all pages
 * (home, benchmark, forecast, access, pulse) automatically reflect the new data.
 * Do NOT add local per-page overrides — that causes score drift between pages.
 *
 * Current live sources:
 *   - Safety: traffic_fatalities, vru_fatality_share  (Supabase)
 *   - Air quality: pm25_annual, no2_annual            (OpenAQ v3)
 *   - Congestion: congestion_level                    (TomTom Traffic Flow)
 *   - Rail transit: rail_transit_km                   (static JSON, refreshed via script; falls back to Overpass API)
 *   - Cycle infra: cycle_infra_km                     (static JSON, refreshed via script)
 */

import { getLatestSafetyData } from './safety-data';
import { getAllCityPM25, getAllCityNO2 } from './air-quality';
import { getAllCityCongestion } from './traffic-flow';
import { getStaticRailTransitKm, getStaticCyclewayKm, hasStaticTransitData } from './transit-static';
import { fetchTransitData } from './transit-data';
import { CITIES } from '$lib/config/cities';
import { computeMetroNetworkKm, computeRailNetworkKm } from '$lib/utils/transit';
import type { QoLOverrides } from '$lib/config/city-qol-data';

interface RailBreakdown {
	totalKm: number;
	metroKm: number;
	suburbanRailKm: number;
}

/**
 * Build rail transit km overrides.
 * Prefers static JSON files (instant, no API calls) when populated.
 * Falls back to live Overpass API fetch (sequential, rate-limited) when static data is empty.
 */
async function buildRailTransitOverrides(): Promise<Record<string, RailBreakdown>> {
	// Try static data first (generated by scripts/refresh-transit-data.sh)
	if (hasStaticTransitData()) {
		const results: Record<string, RailBreakdown> = {};
		for (const city of CITIES) {
			const staticData = getStaticRailTransitKm(city.id);
			if (staticData && staticData.totalKm > 0) {
				results[city.id] = staticData;
			}
		}
		if (Object.keys(results).length > 0) {
			console.log(`[qol-overrides] Using static transit data for ${Object.keys(results).length} cities`);
			return results;
		}
	}

	// Fallback: live Overpass API fetch (sequential to avoid rate limiting)
	console.log('[qol-overrides] Static transit data not available, falling back to live Overpass fetch');
	const results: Record<string, RailBreakdown> = {};
	const cities = CITIES.filter((c) => c.transitSources);

	for (let i = 0; i < cities.length; i++) {
		const city = cities[i];
		try {
			const data = await fetchTransitData(city.id);
			const metroKm = computeMetroNetworkKm(data.metroLines);
			const suburbanRailKm = computeRailNetworkKm(data.railLines);
			const totalKm = metroKm + suburbanRailKm;
			if (totalKm > 0) {
				results[city.id] = { totalKm, metroKm, suburbanRailKm };
			}
		} catch (e) {
			console.error(`[qol-overrides] Rail transit fetch failed for ${city.id}:`, (e as Error).message);
		}
		// Brief pause between cities to be a good Overpass API citizen
		if (i < cities.length - 1) {
			await new Promise((r) => setTimeout(r, 500));
		}
	}

	return results;
}

export async function buildQoLOverrides(): Promise<QoLOverrides> {
	const [safety, airQuality, no2Data, congestion, railTransit] = await Promise.all([
		getLatestSafetyData(),
		getAllCityPM25(),
		getAllCityNO2(),
		getAllCityCongestion(),
		buildRailTransitOverrides()
	]);

	const overrides: QoLOverrides = {};

	// Safety: traffic_fatalities + vru_fatality_share
	for (const [cityId, data] of Object.entries(safety)) {
		overrides[cityId] = { traffic_fatalities: data.fatalitiesPerLakh };
		if (data.vruFatalityShare !== null) {
			overrides[cityId].vru_fatality_share = data.vruFatalityShare;
		}
	}

	// Air quality: pm25_annual
	for (const [cityId, data] of Object.entries(airQuality)) {
		if (data) {
			overrides[cityId] = { ...overrides[cityId], pm25_annual: data.pm25Avg };
		}
	}

	// Air quality: no2_annual
	for (const [cityId, data] of Object.entries(no2Data)) {
		if (data) {
			overrides[cityId] = { ...overrides[cityId], no2_annual: data.no2Avg };
		}
	}

	// Congestion: congestion_level
	for (const [cityId, data] of Object.entries(congestion)) {
		if (data) {
			overrides[cityId] = { ...overrides[cityId], congestion_level: data.congestionPct };
		}
	}

	// Rail transit: rail_transit_km (metro + suburban from static JSON or Overpass geometries)
	// Also stores metro_km and suburban_rail_km as display-only breakdown fields
	// (not in INDICATOR_DEFINITIONS, so they don't affect scoring)
	for (const [cityId, breakdown] of Object.entries(railTransit)) {
		overrides[cityId] = {
			...overrides[cityId],
			rail_transit_km: breakdown.totalKm,
			metro_km: breakdown.metroKm,
			suburban_rail_km: breakdown.suburbanRailKm
		};
	}

	// Cycle infrastructure: cycle_infra_km (from static JSON, refreshed via script)
	for (const city of CITIES) {
		const cyclewayKm = getStaticCyclewayKm(city.id);
		if (cyclewayKm !== null && cyclewayKm > 0) {
			overrides[city.id] = { ...overrides[city.id], cycle_infra_km: cyclewayKm };
		}
	}

	return overrides;
}
